import os
import re
import time
import importlib.util
import sys
import logging
import textwrap

class SkillManager:
    """
    Manages the lifecycle of Dynamic Skills (Cognitive Skills) generated by the system.
    Responsibility:
    1. Extract code from Insights (Markdown).
    2. Save code to 'data/skills/'.
    3. Load and Execute skills safely.
    """
    def __init__(self, skill_dir="data/skills"):
        self.skill_dir = os.path.abspath(skill_dir)
        os.makedirs(self.skill_dir, exist_ok=True)
        self.logger = logging.getLogger("SkillManager")
        
        # Ensure skill_dir is in python path for imports
        if self.skill_dir not in sys.path:
            sys.path.append(self.skill_dir)

    def extract_code_from_markdown(self, content: str) -> str:
        """
        Extracts the first Python code block from markdown content.
        """
        pattern = r"```python(.*?)```"
        match = re.search(pattern, content, re.DOTALL)
        if match:
            code = match.group(1)
            # Remove common indentation
            return textwrap.dedent(code).strip()
        return None

    def save_skill(self, code: str, name_hint: str = "skill") -> str:
        """
        Saves the code to a file.
        Returns the module name.
        """
        timestamp = int(time.time())
        # Sanitize name
        safe_name = "".join(c for c in name_hint if c.isalnum() or c == "_")
        if not safe_name:
            safe_name = "generated_skill"
            
        filename = f"{safe_name}_{timestamp}.py"
        filepath = os.path.join(self.skill_dir, filename)
        
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(code)
            self.logger.info(f"Skill saved to {filepath}")
            return filename.replace(".py", "")
        except Exception as e:
            self.logger.error(f"Failed to save skill: {e}")
            return None

    def load_skill_module(self, module_name: str):
        """
        Dynamically loads a skill module.
        """
        try:
            filepath = os.path.join(self.skill_dir, f"{module_name}.py")
            if not os.path.exists(filepath):
                raise FileNotFoundError(f"Skill file {filepath} not found.")

            spec = importlib.util.spec_from_file_location(module_name, filepath)
            module = importlib.util.module_from_spec(spec)
            sys.modules[module_name] = module
            spec.loader.exec_module(module)
            return module
        except Exception as e:
            self.logger.error(f"Failed to load skill {module_name}: {e}")
            raise

    def execute_skill(self, module_name: str, function_name="main", **kwargs):
        """
        Executes a specific function in the skill module.
        Default entry point is 'main' or 'run'.
        """
        try:
            module = self.load_skill_module(module_name)
            
            # Try to find a callable entry point
            entry_point = getattr(module, function_name, None)
            if not entry_point:
                # Fallback to 'run' or 'execute'
                for fallback in ['run', 'execute', 'solve']:
                    entry_point = getattr(module, fallback, None)
                    if entry_point:
                        break
            
            if not callable(entry_point):
                return f"Error: No callable entry point found in {module_name}. Expected '{function_name}' or 'run/execute'."
            
            # Execute
            result = entry_point(**kwargs)
            return result
        except Exception as e:
            return f"Error executing skill {module_name}: {e}"

    def list_skills(self):
        """Returns a list of available skill modules."""
        files = [f.replace(".py", "") for f in os.listdir(self.skill_dir) if f.endswith(".py")]
        return sorted(files)
