import os
import json
import time
import logging
import pyautogui
from typing import Dict, List, Optional, Any
from datetime import datetime
from core.desktop_automation import DesktopController

# Configure logging
logger = logging.getLogger(__name__)

class SkillMetadata:
    def __init__(self, name: str, description: str, steps: List[Dict]):
        self.name = name
        self.description = description
        self.steps = steps
        self.created_at = datetime.now().isoformat()

class SkillLibrary:
    """
    Manages the storage and retrieval of macro skills.
    """
    def __init__(self, storage_path: str = "memory/skills"):
        self.storage_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), storage_path)
        if not os.path.exists(self.storage_path):
            os.makedirs(self.storage_path)
        self.skills = {}
        self._load_skills()

    def _load_skills(self):
        """Load all skills from disk."""
        if not os.path.exists(self.storage_path):
            return

        for filename in os.listdir(self.storage_path):
            if filename.endswith(".json"):
                try:
                    filepath = os.path.join(self.storage_path, filename)
                    with open(filepath, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        self.skills[data['name']] = data
                except Exception as e:
                    logger.error(f"Failed to load skill from {filename}: {e}")

    def save_skill(self, name: str, description: str, steps: List[Dict]):
        """Save a new skill to the library."""
        skill_data = {
            "name": name,
            "description": description,
            "steps": steps,
            "created_at": datetime.now().isoformat()
        }
        
        filename = f"{name.replace(' ', '_').lower()}.json"
        filepath = os.path.join(self.storage_path, filename)
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(skill_data, f, indent=2, ensure_ascii=False)
            self.skills[name] = skill_data
            logger.info(f"Skill '{name}' saved successfully.")
            return True
        except Exception as e:
            logger.error(f"Failed to save skill '{name}': {e}")
            return False

    def get_skill(self, name: str) -> Optional[Dict]:
        """Retrieve a skill by name."""
        return self.skills.get(name)

    def list_skills(self) -> List[str]:
        """List all available skills."""
        return list(self.skills.keys())

class MacroPlayer:
    """
    Executes macro skills using the DesktopController.
    """
    def __init__(self, controller, skill_library: SkillLibrary):
        self.controller = controller
        self.skill_library = skill_library
        self.is_playing = False

    def play_macro(self, macro_name: str, speed: float = 1.0) -> bool:
        """
        Execute a named macro.
        
        Args:
            macro_name: Name of the macro to play.
            speed: Playback speed multiplier (not yet implemented).
        """
        skill = self.skill_library.get_skill(macro_name)
        if not skill:
            logger.error(f"Macro '{macro_name}' not found.")
            return False

        logger.info(f"▶️ Playing macro: {macro_name}")
        self.is_playing = True
        
        try:
            steps = skill.get('steps', [])
            for step in steps:
                if not self.is_playing:
                    break
                
                self._execute_step(step)
                time.sleep(0.1) # Small delay between steps
            
            logger.info(f"✅ Macro '{macro_name}' execution complete.")
            return True
        except Exception as e:
            logger.error(f"❌ Macro execution failed: {e}")
            return False
        finally:
            self.is_playing = False

    def _execute_step(self, step: Dict):
        """Execute a single macro step."""
        action = step.get('action')
        params = step.get('params', {})
        
        if action == 'click':
            x = params.get('x')
            y = params.get('y')
            if x is not None and y is not None:
                # Use pyautogui directly or via controller if available
                pyautogui.click(x, y)
        
        elif action == 'type':
            text = params.get('text')
            if text:
                pyautogui.write(text)
        
        elif action == 'key':
            key = params.get('key')
            if key:
                pyautogui.press(key)
                
        elif action == 'wait':
            duration = params.get('duration', 1.0)
            time.sleep(duration)
            
        # Add more actions as needed

    def stop(self):
        """Stop current macro execution."""
        self.is_playing = False

class MacroSystem:
    """
    Unified facade for the Macro System (Library + Player + Controller).
    """
    def __init__(self):
        self.controller = DesktopController()
        self.library = SkillLibrary()
        self.player = MacroPlayer(self.controller, self.library)
        
    def learn_skill(self, name: str, description: str, steps: List[Dict]):
        return self.library.save_skill(name, description, steps)
        
    def perform_skill(self, name: str) -> bool:
        return self.player.play_macro(name)
        
    def list_skills(self) -> List[str]:
        return self.library.list_skills()
