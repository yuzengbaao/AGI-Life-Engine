import json
import os
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional

logger = logging.getLogger("SkillLibrary")

class SkillLibrary:
    """
    The AGI's "Fluid Skill Store".
    Stores:
    1. Declarative Knowledge (Workflows, Notes) - Crystallized
    2. Procedural Knowledge (Executable Code, Macros) - Fluid/Narrow Tools
    """
    def __init__(self):
        # Path: data/memory/learned_skills.json
        self.base_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "memory")
        self.skills_file = os.path.join(self.base_dir, "learned_skills.json")
        self.code_dir = os.path.join(self.base_dir, "executable_skills")
        
        # Ensure directories exist
        os.makedirs(self.base_dir, exist_ok=True)
        os.makedirs(self.code_dir, exist_ok=True)
        
        self.skills = self._load()

    def _load(self) -> List[Dict]:
        if os.path.exists(self.skills_file):
            try:
                with open(self.skills_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Failed to load skills: {e}")
                return []
        return []

    def save(self):
        try:
            with open(self.skills_file, 'w', encoding='utf-8') as f:
                json.dump(self.skills, f, indent=2, ensure_ascii=False)
            logger.info("Skill Library saved.")
        except Exception as e:
            logger.error(f"Failed to save skills: {e}")

    def add_executable_skill(self, name: str, description: str, code: str, skill_type: str = "python_script"):
        """
        Saves a generated tool/script as a reusable skill.
        This is the "Fluid" part - creating new organs for new tasks.
        """
        # 1. Save code to file
        safe_name = "".join([c if c.isalnum() else "_" for c in name])
        filename = f"{safe_name}.py"
        file_path = os.path.join(self.code_dir, filename)
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code)
        except Exception as e:
            logger.error(f"Failed to write skill code: {e}")
            return None

        # 2. Add metadata entry
        entry = {
            "id": f"skill_{int(datetime.now().timestamp())}_{safe_name}",
            "name": name,
            "type": "executable",
            "subtype": skill_type,
            "description": description,
            "file_path": file_path, # Absolute path
            "created_at": str(datetime.now()),
            "usage_count": 0,
            "success_rate": 1.0
        }
        
        # Check for duplicates (update if exists)
        existing = next((s for s in self.skills if s.get("name") == name), None)
        if existing:
            self.skills.remove(existing)
            
        self.skills.append(entry)
        self.save()
        logger.info(f"Added executable skill: {name}")
        return entry

    def get_skill_by_name(self, name: str) -> Optional[Dict]:
        return next((s for s in self.skills if s.get("name") == name), None)

    def list_executable_skills(self) -> List[str]:
        return [s["name"] for s in self.skills if s.get("type") == "executable"]

    def add_learned_session(self, session_type: str, raw_observations: List[str], summary: str, extracted_logic: str):
        """
        Record a learning session.
        """
        entry = {
            "id": f"skill_{int(datetime.now().timestamp())}",
            "timestamp": str(datetime.now()),
            "type": session_type,  # e.g., "CAD_Drafting", "Python_Coding"
            "summary": summary,    # High-level description
            "logic_flow": extracted_logic, # The "Algorithm" of what user did
            "raw_observations_count": len(raw_observations),
            "mastery_level": "Novice" # Start as Novice
        }
        self.skills.append(entry)
        self.save()
        return entry

    def get_recent_learnings(self, limit=5):
        return self.skills[-limit:]
